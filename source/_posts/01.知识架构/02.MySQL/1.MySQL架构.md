---
title: MySQL组成原理
date: 2020/03/28 11:03:01
tags: 
 - MySQL
categories: 
 - MySQL
---

# 一、架构

MySQL架构分两层：server层和存储引擎层

## server层
负责建立连接、执行和分析SQL。
**1. connectors** 

与其他编程语言中的sql 语句进行交互，如php、java等。

**2. Management Serveices & Utilities**

系统管理和控制工具

**3. Connection Pool (连接池)**

管理缓冲用户连接，线程处理等需要缓存的需求

**4. SQL Interface (SQL接口)**

接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface

**5. Parser （解析器）**

SQL命令传递到解析器的时候会被解析器验证和解析。

主要功能：

a . 将SQL语句分解成数据结构，并将这个结构传递到后续步骤，后面SQL语句的传递和处理就是基于这个结构的

b. 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的，语句将不会继续执行下去

**6. Optimizer (查询优化器)**

SQL语句在查询之前会使用查询优化器对查询进行优化(产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果) 他使用的是“选取-投影-联接”策略进行查询。

用一个例子就可以理解：select uid,name from user where gender = 1;

这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤

这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤

将这两个查询条件联接起来生成最终查询结果.

**7. Cache和Buffer (查询缓存)**

如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等

**8.Engine (存储引擎)**

存储引擎是MySql中具体的与文件打交道的子系统。也是Mysql最具有特色的一个地方。

Mysql的存储引擎是插件式的。它根据MySql AB公司提供的文件访问层的一个抽象接口来定制一种文件访问机制（这种访问机制就叫存储引擎）

**9.文件和日志**

# 二、**SQL 语句执行过程**

数据库通常不会被直接使用，而是由其他编程语言通过SQL语句调用mysql，由mysql处理并返回执行结果。那么Mysql接受到SQL语句后，又是如何处理

首先程序的请求会通过mysql的connectors与其进行交互，请求到处后，会暂时存放在连接池（connection pool)中并由处理器（Management Serveices & Utilities）管理。当该请求从等待队列进入到处理队列，管理器会将该请求丢给SQL接口（SQL Interface）。SQL接口接收到请求后，它会将请求进行hash处理并与缓存中的结果进行对比，如果完全匹配则通过缓存直接返回处理结果；否则，需要完整的走一趟流程：

(1)由SQL接口丢给后面的解释器（Parser），解释器会判断SQL语句正确与否，若正确则将其转化为数据结构。

(2)解释器处理完，便来到后面的优化器（Optimizer），它会产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果。

(3)确定最优执行计划后，SQL语句此时便可以交由存储引擎（Engine）处理，存储引擎将会到后端的存储设备中取得相应的数据，并原路返回给程序。

**(1)如何缓存查询数据**

存储引擎处理完数据，并将其返回给程序的同时，它还会将一份数据保留在缓存中，以便更快速的处理下一次相同的请求。具体情况是，mysql会将查询的语句、执行结果等进行hash，并保留在cache中，等待下次查询。

**(2)buffer与cache的区别**

从mysql原理图可以看到，缓存那里实际上有buffer和cache两个，那它们之间的区别：简单的说就是，buffer是写缓存，cache是读缓存。

**(3)如何判断缓存中是否已缓存需要的数据**

这里可能有一个误区，觉得处理SQL语句的时候，为了判断是否已缓存查询结果，会将整个流程走一遍，取得执行结果后再与需要的进行对比，看看是否命中，并以此说，既然不管缓存中有没有缓存到查询内容，都要整个流程走一遍，那缓存的优势在哪？

其实并不是这样，在第一次查询后，mysql便将查询语句以及查询结果进行hash处理并保留在缓存中，SQL查询到达之后，对其进行同样的hash处理后，将两个hash值进行对照，如果一样，则命中，从缓存中返回查询结果；否则，需要整个流程走一遍。



当数据库中有多个操作需要修改同一数据时，不可避免的会产生数据的脏读。这时就需要数据库具有良好的并发控制能力，这一切在MySQL中都是由服务器和存储引擎来实现的。


解决并发问题最有效的方案是引入了锁的机制，锁在功能上分为共享锁(shared lock)和排它锁(exclusive lock)即通常说的读锁和写锁。当一个select语句在执行时可以施加读锁，这样就可以允许其它的select操作进行，因为在这个过程中数据信息是不会被改变的这样就能够提高数据库的运行效率。当需要对数据更新时，就需要施加写锁了，不在允许其它的操作进行，以免产生数据的脏读和幻读。锁同样有粒度大小，有表级锁(table lock)和行级锁(row lock)，分别在数据操作的过程中完成行的锁定和表的锁定。这些根据不同的存储引擎所具有的特性也是不一样的。


MySQL大多数事务型的存储引擎都不是简单的行级锁，基于性能的考虑，他们一般都同时实现了多版本并发控制(MVCC)。这一方案也被Oracle等主流的关系数据库采用。它是通过保存数据中某个时间点的快照来实现的，这样就保证了每个事务看到的数据都是一致的。

# 三、事务

简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。

## 3.1 特性

原子性(atomicity):事务中的所有操作要么全部提交成功，要么全部失败回滚。
一致性(consistency):数据库总是从一个一致性状态转换到另一个一致性状态。
隔离性(isolation):一个事务所做的修改在提交之前对其它事务是不可见的。
持久性(durability):一旦事务提交，其所做的修改便会永久保存在数据库中。

## 3.2 隔离级别

#### 3.2.1 READ UNCOMMITTED(读未提交)

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

#### 3.2.2 READ COMMITTED(读已提交)

一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

#### 3.2.3 REPEATABLE READ(可重复读)

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

#### 3.2.4 SERIALIZABLE(串行化)

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

## 3.3 多版本并发控制（MVCC ）

是通过保存数据在某个时间点的快照来实现并发控制的。也就是说，不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

简单来说， **多版本并发控制**的思想就是保存数据的历史版本，通过对数据行的多个版本管理来实现数据库的并发控制。这样我们就可以通过比较版本号决定数据是否显示出来，读取数据的时候不需要加锁也可以保证事务的隔离效果。

#### 3.3.1 当前读和快照读

## 3.4 死锁

两个或多个事务在同一资源上相互占用并请求锁定对方占用的资源，从而导致恶性循环的现象。MySQL的部分存储引擎能够检测到死锁的循环依赖并产生相应的错误。InnoDB引擎解决死锁的方案是将持有最少排它锁的事务进行回滚。

# 四、Mysql 与 磁盘交互的过程

## 1、Mysql 交互模型（站在OS的角度）

核心理念说在最前面，Mysql 对数据所做的所有访问，无论是查询，还是增删改，都是在内存中进行的！

### (1) Mysql 从磁盘读数据

早在Mysql 启动的时候，Mysql 就会向内存申请一块空间（下面统称“缓存池”）。

每次查询的时候，会预先从磁盘读取一部分相关数据到缓存池。（至于读取多少，详见“Mysql和磁盘交互的基本单位”）

每次增删改的时候，如果缓存池里存在对应的记录，那就直接在已有的记录上改；如果不存在，那就先从磁盘读取到缓存池，然后再改。

### (2) Mysql 向磁盘写数据

所有的增删改查都在内存中进行，每次执行sql的时候都会在缓存池中先把数据调整好，然后再刷新到内核缓冲区。内核有自己刷新策略，会定期把数据从内核缓冲区刷新到磁盘。

从缓存池 ==》内核缓冲区的刷新策略有以下三种选择：

有脏数据就立马刷新（脏数据是内存操作完毕以后的数据）
定期刷新
达到一定的数据量再刷新
从内核缓冲区 ==》磁盘的刷新则是定期刷新。如果想要手动刷新内核缓冲区，可以参考系统调用接口 syncfs 。

## 2、Mysql 交互的基本单位

### (1) 交互的基本单位（每次IO的数据量）

上面提到，查询时，Mysql 会读取一部分数据到缓存池，那么问题来了，每次到底读取多少呢？

Mysql和外设交互的基本单位是16KB，即一次IO的数据量就是16KB，站在Mysql的角度，这16KB就是一个page。读数据时，将以page为单位，把相关数据从磁盘读取到内存；写数据也是同理。

### (2) 为什么IO交互要以page为基本单位？

假设每次查询都只读取一条记录，多次查询的时候，就要频繁跟数据库（简单理解为磁盘）交互。系统和磁盘的IO是比较费时的，为了提升效率，一般我们要尽量减少系统和磁盘IO的次数。

如果每次查询，我们以page（16KB）读取数据，那就相当于我们可以一次读取几百条记录到缓存池中，即便我们后续要频繁查询数据库，只要是在这个 page 里的内容，我们便无需和磁盘IO。