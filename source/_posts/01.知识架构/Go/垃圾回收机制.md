---
title: 垃圾回收机制
date: 2022/10/27 22:41:16
tags:
  - Go
categories:
  - Go
---

# 一、垃圾回收机制

## 1.1 三色标记法

1. 把所有对象放入白色集合中   
2. 从根节点开始遍历对象，把遍历到的白色对象从白色集合放入到灰色集合   
3. 遍历灰色集合，把灰色对象引用到的白色对象放入灰色集合中，同时把遍历到的灰色对象放入黑色集合中  
4. 重复3步骤，直到灰色集合为空
5. 前面的步骤结束后，白色的对象就是不可达对象，是需要回收的

## 1.2 写屏障





# 二、内存逃逸

`Go`语言的逃逸分析总共实现了两个版本：

- 1.13版本前是第一版
- 1.13版本后是第二版

粗略看了一下逃逸分析的代码，大概有`1500+`行（go1.15.7）。代码我倒是没仔细看，注释我倒是仔细看了一遍，注释写的还是很详细的，代码路径：src/cmd/compile/internal/gc/escape.go，大家可以自己看一遍注释，其逃逸分析原理如下：

- `pointers to stack objects cannot be stored in the heap`：指向栈对象的指针不能存储在堆中
- `pointers to a stack object cannot outlive that object`：指向栈对象的指针不能超过该对象的存活期，也就说指针不能在栈对象被销毁后依旧存活。（例子：声明的函数返回并销毁了对象的栈帧，或者它在循环迭代中被重复用于逻辑上不同的变量）

我们大概知道它的分析准则是什么就好了，具体逃逸分析是怎么做的，感兴趣的同学可以根据源码自行研究。

既然逃逸分析是在编译阶段进行的，那我们就可以通过`go build -gcflags '-m -m -l'`命令查看到逃逸分析的结果，我们之前在分析内联优化时使用的`-gcflags '-m -m'`，能看到所有的编译器优化，这里使用`-l`禁用掉内联优化，只关注逃逸优化就好了。

现在我们也知道了逃逸分析，接下来我们就看几个逃逸分析的例子。

## 内存逃逸分析

1. 使用pprof确定是那一个方法内存消耗高
2. 使用go build --gcflag -m -l 来确定是哪一个内存逃逸
3. 如果有内存逃逸的现象，会提示escape to heap

## 2.1  函数返回局部指针变量

先看例子：

```go
func Add(x,y int) *int {
	res := 0
	res = x + y
	return &res
}

func main()  {
	Add(1,2)
}
```

查看逃逸分析结果：

```go
go build -gcflags="-m -m -l" ./test1.go
# command-line-arguments
./test1.go:6:9: &res escapes to heap
./test1.go:6:9:         from ~r2 (return) at ./test1.go:6:2
./test1.go:4:2: moved to heap: res
复制代码
```

分析结果很明了，函数返回的局部变量是一个指针变量，当函数`Add`执行结束后，对应的栈桢就会被销毁，但是引用已经返回到函数之外，如果我们在外部解引用地址，就会导致程序访问非法内存，就像上面的`C`语言的例子一样，所以编译器经过逃逸分析后将其在堆上分配内存。

## 2.2  interface类型逃逸

先看一个例子：

```go
func main()  {
	str := "asong太帅了吧"
	fmt.Printf("%v",str)
}
```

查看逃逸分析结果：

```go
go build -gcflags="-m -m -l" ./test2.go 
# command-line-arguments
./test2.go:9:13: str escapes to heap
./test2.go:9:13:        from ... argument (arg to ...) at ./test2.go:9:13
./test2.go:9:13:        from *(... argument) (indirection) at ./test2.go:9:13
./test2.go:9:13:        from ... argument (passed to call[argument content escapes]) at ./test2.go:9:13
./test2.go:9:13: main ... argument does not escape
```

`str`是`main`函数中的一个局部变量，传递给`fmt.Println()`函数后发生了逃逸，这是因为`fmt.Println()`函数的入参是一个`interface{}`类型，如果函数参数为`interface{}`，那么在编译期间就很难确定其参数的具体类型，也会发送逃逸。

观察这个分析结果，我们可以看到没有`moved to heap: str`，这也就是说明`str`变量并没有在堆上进行分配，只是它存储的值逃逸到堆上了，也就说任何被`str`引用的对象必须分配在堆上。如果我们把代码改成这样：

```go
func main()  {
	str := "asong太帅了吧"
	fmt.Printf("%p",&str)
}
```

查看逃逸分析结果：

```go
go build -gcflags="-m -m -l" ./test2.go
# command-line-arguments
./test2.go:9:18: &str escapes to heap
./test2.go:9:18:        from ... argument (arg to ...) at ./test2.go:9:12
./test2.go:9:18:        from *(... argument) (indirection) at ./test2.go:9:12
./test2.go:9:18:        from ... argument (passed to call[argument content escapes]) at ./test2.go:9:12
./test2.go:9:18: &str escapes to heap
./test2.go:9:18:        from &str (interface-converted) at ./test2.go:9:18
./test2.go:9:18:        from ... argument (arg to ...) at ./test2.go:9:12
./test2.go:9:18:        from *(... argument) (indirection) at ./test2.go:9:12
./test2.go:9:18:        from ... argument (passed to call[argument content escapes]) at ./test2.go:9:12
./test2.go:8:2: moved to heap: str
./test2.go:9:12: main ... argument does not escape
```

这回`str`也逃逸到了堆上，在堆上进行内存分配，这是因为我们访问`str`的地址，因为入参是`interface`类型，所以变量`str`的地址以实参的形式传入`fmt.Printf`后被装箱到一个`interface{}`形参变量中，装箱的形参变量的值要在堆上分配，但是还要存储一个栈上的地址，也就是`str`的地址，堆上的对象不能存储一个栈上的地址，所以`str`也逃逸到堆上，在堆上分配内存。（**这里注意一个知识点：Go语言的参数传递只有值传递**）。
