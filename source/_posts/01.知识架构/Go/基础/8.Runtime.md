---
title: runtime
date: 2022/11/02 15:20:21
tags:
  - Go
categories:
  - Go
---



# runtime

<!-- more -->

## 一、Goroutine

### 1. 定义

`goroutine` 是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理。Go 程序会智能地将 `goroutine`中的任务合理地分配给每个 CPU。

goroutine是一个与其他goroutines并行运行在同一地址空间的go函数或者方法。一个运行的程序由一个或者更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine。

### 2.goroutine 和 thread的区别

1. 内存占用。goroutine的内存开销小，一个goroutine内存开销在2k左右，而thread的开销在1-8M，并且为了防止栈溢出导致污染其他线程，线程间还有guard page的存在，内存开销大。
2. 创建和销毁。thread是内核级的，内核调用消耗的性能代价比较高，开销较大。而goroutine是一种用户态线程，由go runtime管理，创建和销毁的销毁代价小。

### 3.启动

```go
go func(){

}
```



## 二、GMP模型

### 1. 基本流程

G:`goroutine`协程。
M:`Machine` 内核级线程的封装，默认最大数量是10000。
P:`Processor` G和M的调度对象，用来调度G和M之间的关系，数量可以通过GOMAXPROCS()来设置。

1. 每个P有个局部队列，局部队列保存着待执行的`goroutine`，当时局部队列满了之后，会把`goroutine`放到全局队列中；
2. 每个M绑定了一个P，M是真正执行`goroutine`的实体，M从绑定的P中获取G来执行；  
3. 当M绑定的P的局部队列为空时，会从全局队列获取G放到本地队列来执行，当全局队列也为空时，M会从其他局部队列中获取G来执行，这个方式称为`work stealing`；  
4. 当G因为系统调用而阻塞时，P和M会进行解绑，这个过程称之为hand off，并寻找新的空闲M，如果没有找到空闲M，则会新建一个M；  
5. 当G因为`channel`或者`network I/O` 阻塞时，不会阻塞M，此时M会寻找其他`runnable`的G，当阻塞的G恢复后会重新进入`runnable`状态进行P等待执行；  

### 2. work stealing

当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。

### 3. hand off

当本线程M0因为G0进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。进而某个空闲的M1获取P，继续执行P队列中剩下的G。而M0由于陷入系统调用而进被阻塞，M1接替M0的工作，只要P不空闲，就可以保证充分利用CPU。M1的来源有可能是M的缓存池，也可能是新建的。当G0系统调用结束后，根据M0是否能获取到P，将会将G0做不同的处理：

1. 如果有空闲的P，则获取一个P，继续执行G0。
2. 如果没有空闲的P，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。

## 三、协作与抢占

如果某个 G 执行时间过长，其他的 G 如何才能被正常的调度？ 这便涉及到有关调度的两个理念：协作式调度与抢占式调度。



## 四、协程泄漏

排查方式：

1. 使用火焰图确定是哪一段代码内存消耗高
2. 使用pprof top 监控是不是有地方发生了协程泄漏
3. 使用list命令确定协程是在哪一行代码阻塞
