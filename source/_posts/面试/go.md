---
title: go面试题
date: 2022/9/27 15:18:37
tags:
  - mysql
  - 面试
categories:
  - mysql
  - 面试
---

## 2. 同步锁
当一个 Goroutine（协程）获得了 Mutex 后，其他 Goroutine（协程）就只能乖乖的等待，除非该 Goroutine 释放了该 Mutex。RWMutex 在读锁占用的情况下，会阻止写，但不阻止读 RWMutex。 在写锁占用情况下，会阻止任何其他Goroutine（无论读和写）进来，整个锁相当于由该 Goroutine 独占同步锁的作用是保证资源在使用时的独有性，不会因为并发而导致数据错乱，保证系统的稳定性。

## 3. Golang与Java区别
Go语言：
编译部署：Go针对不同的平台，编译对应的机器码；Java通过虚拟机编译，使用JVM跨平台编译；
并发性：golang是一种多核计算机设计的语言，天生支持并发，并且拥有GMP模型，减少了并发切换线程的性能开销；Java中仍然是内核级线程，多线程开发依然需要复杂的实现，而且实现方法有很多种，需要了解每种的优缺点才能写出高性能代码；
内存管理：Go的垃圾收集更快，基于三色收集法；Java的垃圾收集为分代收集法；
接口：Go语言隐式的声明和实现接口；Java需要直接实现接口。


## 4. channel
如果给一个nil的channel发送数据，会造成永久阻塞；
如果从一个nil的channel中接收数据，会造成永久阻塞；
给一个已经关闭channel发送数据，会引起panic；
从一个已经关闭的channel中接收数据，如果缓冲区为空，则返回一个零值；
如果channel有缓冲，则channel是非同步的，如果channel没有缓冲，则是同步的。

ring buffer是一个环形队列，环形队列有一个读索引和写索引，当读写索引指向同一个地方时，根据qcount判断是满的还是空的。


## 5. new 和 make
new 是用来分配空间，传递给new函数的是一个类型，而不是一个值，返回值是指向这个新分配的地址的指针；
make 用于slice，map和chan的初始化，返回的是一个实例；

## 6. defer的执行顺序
defer在return之后执行，在panic之前执行，并且先写的defer后执行，如果defer的过程中发生了panic，会跳过这个defer，执行下一个defer

## 7. slice
slice是基于数组实现的，它内部存在一个指针指向底层数组，扩容的时候，如果新申请的容量大于两倍旧容量，则最终容量就是新申请的容量，否则判断旧切片长度，如果小于1024，则分配两倍的旧切片容量，如果大于1024，则在原来的基础上增加1/4长度的容量。
如果原数组还有容量可以扩容，那么指向的是原数组，如果原来的已经达到了最大值，那么会开辟新的数组并指向新的数组。

## 8. map
map的底层是中是一个桶数组的形式，其中通过hash的低B位选择是哪个桶，高八位确定在桶中的哪个位置。
哈希碰撞的解决办法：  
开放寻址法：依次探测和比较数组中的元素以判断目标键值对是否存在哈希表中，当发生写入发生冲突时，将会插入到下一个索引不为空的地方。性能受装载因子的影响，他是数组中的元素和数组大小的比值。
拉链法：键值对中，key会经过一个hash函数，并通过低B位来选择一个hash桶，如果在桶中找到了键相同的键值对，就更新对应的值，如果没有找到键相同的键值对，则在末尾追加新的键值对。  

map会在以下两种情况下发生扩容：
- 装载因子超过6.5，增量扩容，大小是原来的两倍
- 哈希使用了太多溢出桶，等量扩容

## 9. Mutex 
### 四种状态
- Locked - 互斥锁锁定状态
- Woken - 是否有协程已被唤醒
- Starving - 是否处于饥饿状态
- Waiter - 表示等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量

### 两种模式
- normal 所有等待锁的goroutine按照FIFO顺序等待，唤醒的goroutine不会直接拥有锁，而是和新请求的goroutine竞争锁，新请求的goroutine更容易竞争到锁，因为它正在CPU上执行，所以刚刚唤醒的goroutine很大可能会竞争失败，这种情况下，会把刚刚唤醒的goroutine放到队列前面，而且加锁不成功会判断是否满足自旋条件，如果满足则会自动自旋，尝试抢锁
- 饥饿模式 在饥饿模式下，会直接由unlock把锁交给队列第一位的goroutine，新进来的锁也不会进入自旋状态而是放到队尾，当一个goroutine等待锁时间超过1ms时，当前队列只剩下一个goroutine时，Mutex切换到饥饿模式

### 自旋条件
- 锁已经被占用了，并且锁不处于饥饿模式
- 积累的自选次数小于4次
- CPU核数大于1
- 有空闲的P
- 当前Goroutine所挂载的P下，本地队列为空


## 10. GMP 模型
G：goroutine 协程
M：Machine 内核级线程的封装，默认最大数量是10000
P：Processor G和M的调度对象，用来调度G和M之间的关系，数量可以通过GOMAXPROCS()来设置

1. 每个P有个局部队列，局部队列保存着待执行的goroutine，当时局部队列满了之后，会把goroutine放到全局队列中  
2. 每个M绑定了一个P，M是真正执行goroutine的实体，M从绑定的P中获取G来执行
3. 当M绑定的P的局部队列为空时，会从全局队列获取G放到本地队列来执行，当全局队列也为空时，M会从其他局部队列中获取G来执行，这个方式称为work stealing  
4. 当G因为系统调用而阻塞时，P和M会进行解绑，这个过程称之为hand off，并寻找新的空闲M，如果没有找到空闲M，则会新建一个M
5. 当G因为channel或者network I/O 阻塞时，不会阻塞M，此时M会寻找其他runnable的G，当阻塞的G恢复后会重新进入runnable状态进行P等待执行


## 11. 基于信号的抢占式调
