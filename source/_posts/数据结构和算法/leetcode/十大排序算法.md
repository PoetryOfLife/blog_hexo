---
title: 基础概念
date: 2022/04/21 19:32:22
tags:
  - 算法
  - 排序
categories:
  - 算法
  - 排序
---

##  冒泡排序
重复扫描需要排序的序列，比较相邻的两个元素，如果他们顺序错误就把他们交换位置，最大的时间复杂度为O(n^2)，空间复杂度为O(1)
```go
// BubbleSort 冒牌排序
func BubbleSort(ary []int) []int {
	for i := range ary {
		for j := 0; j < len(ary)-1-i; j++ {
			if ary[j] > ary[j+1] {
				ary[j], ary[j+1] = ary[j+1], ary[j]
			}
		}
	}
	return ary
}
```


## 选择排序
冒泡升级版，旨在把数组中最大（最小）一一选择出来放在前面，时间复杂度为O(n^2)，空间复杂度为O(1)
```go
// SelectSort 选择排序
func SelectSort(ary []int) []int {
	length := len(ary)
	for i := 0; i < length; i++ {
		index := i
		for j := i; j < length; j++ {
			if ary[j] < ary[index] {
				index = j
			}
		}
		if index != i {
			ary[index], ary[i] = ary[i], ary[index]
		}
	}
	return ary
}
```

## 插入排序
构建有序序列，对于未排序序列，在已排序序列中从后往前扫描，找到相应的位置并插入，时间复杂度为O(n^2)，空间复杂度为O(1)
```go
// InsertionSort 插入排序
func InsertionSort(ary []int) []int {
	for i := 1; i < len(ary); i++ {
		temp := ary[i]
		index := i
		for index > 0 && temp < ary[index-1] {
			ary[index], ary[index-1] = ary[index-1], ary[index]
			index--
		}
		ary[index] = temp
	}
	return ary
}
```

## 归并排序
把序列拆成子序列，先把子序列排序，再合并，通常使用递归的方式，时间复杂度O(nlogn)，空间复杂度O(n)
```go
// MergeSort 归并排序
func MergeSort(ary []int) []int {
	length := len(ary)
	if length < 2 {
		return ary
	}
	middle := length / 2
	left := ary[0:middle]
	right := ary[middle:]
	return merge(MergeSort(left), MergeSort(right))
}

func merge(left, right []int) (result []int) {
	for len(left) != 0 && len(right) != 0 {
		if left[0] <= right[0] {
			result = append(result, left[0])
			left = left[1:]
		} else {
			result = append(result, right[0])
			right = right[1:]
		}
	}
	for len(left) != 0 {
		result = append(result, left[0])
		left = left[1:]
	}
	for len(right) != 0 {
		result = append(result, right[0])
		right = right[1:]
	}
	return
}
```