---
title: 数组
date: 2019/04/10 17:27:47
tags:
  - 数据结构
  - 数组
categories:
  - 数据结构
  - 数组
---

## 定义
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
1. 线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。
2. 连续的内存空间和相同类型的数据。
  
<!-- more -->

## 低效的“插入”和“删除”
数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，复杂度为O(n)

## 警惕数组的访问越界问题
在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。但并非所有的语言都像 C 一样，把数组越界检查的工作丢给程序员来做，像 Java 本身就会做越界检查，比如下面这几行 Java 代码，就会抛出 java.lang.ArrayIndexOutOfBoundsException。
```java
int[] a = new int[3];
a[3] = 10;
```

## 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：
```C
a[k]_address = base_address + k * type_size
```
但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：
```C
a[k]_address = base_address + (k-1)*type_size
``````
从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。
