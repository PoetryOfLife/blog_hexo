---
title: Docker
date: 2023/08/28 21:21:19
tags: 
 - Docker
categories: 
 - Docker
---

# Docker

## 1.Docker和虚拟机的区别

虚拟机和Docker是不同的

虚拟机基于hypervisor安装操作系统，需要在宿主机上创建虚拟层，虚拟的操作系统，然后再安装应用；

Docker是在宿主机上启动Docker引擎，再引擎的基础上安装应用，不需要额外加载系统，并且docker守护进程会管理所有的容器，本质上是一个进程；

## 2.docker的原理

Docker是基于命名空间namespace，控制组cgroup，文件联合系统控制unionFS实现；

namespace：实现对进程、网络、文件系统等资源的隔离；

cgroup：实现对进程资源的限制与管理；

unionFS：将多个文件层次结合成一个文件系统；Docker容器可以共享一个镜像，并在其上添加各自的应用程序和配置文件；

## 3.docker镜像

### Docker 镜像分层机制

Docker Image是有一个层级结构，最底层的Layer是基础镜像，然后每顺序执行一条指令，生成的Layer按照入栈的顺序累加，最终形成一个Image。

### Docker镜像的生成

Docker镜像是通过DockerFile定义和生成的，DockerFile中的每一条命令的执行结构都会成为Image中的一个Layer。

## 4.Namespce

Namespace彼此之间是隔离的，包括ipc、net、pid。

### PID隔离

fork()是一个linux的函数，它被调用一次时，却能够返回两次（父进程和子进程各返回一次），通过返回值的不同就可以区分父进程和子进程。他可能有三种不同的返回值：

- 在父进程中，fork返回新创建子进程的进程ID
- 在子进程中，fork返回0
- 如果出现错误，fork返回一个负值

利用PID Namespaces，每个容器之间的进程ID都是独立的，不同的namespace之间是可以有相同pid的。

namespace

### NET隔离

管理网络命名空间，每个NET namespace之间有一个独立的network devices，ip addresses，ip routing tables

#### 网络模式

Docker提供了四种不同的网络模式：

- Host：和宿主机共用一个NET Namespce

- Container：和指定的容器共用一个NET Namespace，同时也不会自己创建网卡、IP等。

- None：有自己的NET NS，但是没有网卡、IP、路由等信息，需要自己配置。

- Bridge：Docker进程在主机上启动后，会在主机上创建一个名为docker0的虚拟网桥，在此主机的容器都会默认连接到这个虚拟网桥上，Docker会在docker0的子网中分配一个IP给容器用，并设置docker0的IP地址为容器的默认网关。

  网桥docker0通过iptables的配置与宿主机上的网卡相连，所有符合条件的请求都会通过iptables转发到docker0并由网桥分发给对应的容器。

### IPC隔离

进程间通信命名空间

### MNT隔离

文件系统挂载点命名空间 

### UTS隔离

Unix 时间系统隔离

## 5.Cgroups

Cgroups（Control Groups） 用于对一个或一组进程进行资源控制和监控的机制。
他可以隔离宿主机上的CPU、内存、网络、磁盘I/O和网络带宽。

## 6.unionFS

docker 的创新点在文件系统

docker就是通过overlayFS 一层层叠加起来的，overlay分为两层，镜像层和容器层，其中镜像层是readonly的，容器层是可以写的，overlay会把这两层merged起来，生成一个新的层，layer的由来。



## 7.docker通讯

### 容器之间的通讯

docker 可以设置docker  Network，然后启动时加入--net参数指定network，这个时候/etc/hosts文件中就会加入容器IP和容器名的映射，其他容器就可以通过这个容器名作为域名访问了。

### 跨主机的网络问题

#### Overlay

Overlay网络是为特定目的在物理（底层网络）之上创建的逻辑网络。

Docker Swarm，则是Docker Overlay网络的一种实现方式，它是Docker开发的容器集群管理工具

#### underlay





## 12Factor



## docker build context

docker会把Docker所在目录的问搭建都传到docker daemon

要确保构建上下文的清晰



## bulid cache 

判断是否有可用的已存的镜像，只有不存在时才会重新构建，判断段checksum

当某一层失效时，所有层级的cache均一失效

所以变动少的应该放在下面



## 多段构建

有效减少镜像层级的方式

精简产线，把一些以来放在前期



## Dockerfile

FROM 

LABELS

RUN 容器构建时执行的命令

CMD 容器创建时运行时需要执行的命令

EXPOSE 声明需要监听的端口

ENV 声明环境变量

ADD 从源地址复制文件到目标路径，如果src是一个本地压缩文件，那么他会同时完成解压缩

COPY 只复制本地文件，不解压文件

ENTRYPOINT:定义可以执行的容器镜像入口命令

VOLUME:挂载存储卷

USER:切换运行镜像的用户和用户组

WORKDIR:工作目录



### 最佳实践

易管理、少漏洞、镜像小、层级小、利用缓存

使用的工具尽量少

能合并的层级合并到一起

低频修改的镜像放在下面

选择合理化的初始化进程

需要捕获SIGTERM信号完成子进程的优雅终止

结束僵尸进程



